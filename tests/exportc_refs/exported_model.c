/*
 * Generated by emx-pytorch2c export_generic_c.
 * Options:
 *   function_name: 'model_run'
 *   truncate_weights_after: None
 *   temp_allocation_threshold: 1024
 *   variable_dim_inputs: {}
 *   variable_dim_outputs: {}
 */
#include <stdint.h>
#include <sys/types.h>
#include <stdbool.h>
static const float weight_bias[3] = {
    -0x1.5b4f07p-1f, 0x1.0ce099p+0f, -0x1.091cabp+0f
};

static const float weight_weight[4][3] = {
    {
        0x1.453f5cp+0f, -0x1.163c50p-2f, -0x1.0b7149p+1f
    },
    {
        0x1.1184b6p-1f, -0x1.0ad1a1p+0f, -0x1.33052dp+0f
    },
    {
        0x1.4e837ap-2f, 0x1.5688e5p-1f, -0x1.382144p-1f
    },
    {
        -0x1.4e830bp-2f, -0x1.18bd18p-1f, 0x1.3a67c6p-3f
    }
};

#ifndef REF_PI_F
#define REF_PI_F 3.14159265358979323846f
#endif
#ifndef REF_PI_D
#define REF_PI_D 3.14159265358979323846
#endif


/*
* op: addmm (kind: addmm)
* inputs: [shape=(3,), size=3, shape=(2, 4), size=8, shape=(4, 3), size=12]
* output: shape=(2, 3), size=6
* params: {'alpha': 1.0, 'beta': 1.0}
*/
void node1_addmm_f32(const float input[3], const float mat1[2][4], const float mat2[4][3], float out[2][3]) {
    for (ssize_t i = 0; i < 2; ++i) {
        for (ssize_t j = 0; j < 3; ++j) {
            float acc = 0.0f;
            for (ssize_t t = 0; t < 4; ++t) {
                acc += mat1[i][t] * mat2[t][j];
            }
            out[i][j] = (1.0f) * ((float*)input)[j * 1] + (1.0f) * acc;
        }
    }
}

void ref_codegen_main_f32(const float input_0[2][4], const float input_1[3], const float input_2[4][3], float out[2][3]) {
    node1_addmm_f32(input_1, input_0, input_2, out);
}

void model_run(const float in0[2][4], float out0[2][3]) {
    ref_codegen_main_f32(in0, weight_bias, weight_weight, out0);
}
