{{ signature }}
    for (ssize_t n = 0; n < {{ batch }}; ++n) {
        for (ssize_t c = 0; c < {{ channels }}; ++c) {
            for (ssize_t ol = 0; ol < {{ out_l }}; ++ol) {
                ssize_t in_l_base = (ssize_t)ol * {{ stride }} - {{ padding }};
                {% if pool_kind == "max_pool1d" %}
                bool has_value = false;
                {{ c_type }} max_val = 0;
                for (ssize_t kl = 0; kl < {{ k_l }}; ++kl) {
                    ssize_t in_l_idx = in_l_base + (ssize_t)kl * {{ dilation }};
                    if (in_l_idx < 0 || in_l_idx >= {{ in_l }}) {
                        continue;
                    }
                    {{ c_type }} val = input[n][c][in_l_idx];
                    if (!has_value || val > max_val) {
                        max_val = val;
                        has_value = true;
                    }
                }
                out[n][c][ol] = max_val;
                {% else %}
                {{ c_type }} acc = 0;
                ssize_t count = 0;
                for (ssize_t kl = 0; kl < {{ k_l }}; ++kl) {
                    ssize_t in_l_idx = in_l_base + (ssize_t)kl * {{ dilation }};
                    if (in_l_idx < 0 || in_l_idx >= {{ in_l }}) {
                        continue;
                    }
                    acc += input[n][c][in_l_idx];
                    count += 1;
                }
                ssize_t divisor = count;
                {% if count_include_pad %}
                divisor = {{ k_l }};
                {% endif %}
                {% if has_divisor_override %}
                divisor = {{ divisor_override }};
                {% endif %}
                out[n][c][ol] = acc / ({{ c_type }})divisor;
                {% endif %}
            }
        }
    }
}
